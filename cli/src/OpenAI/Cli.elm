port module OpenAI.Cli exposing (..)

import Elm
import Elm.Annotation
import Elm.Case
import Ext.Http
import Http
import OpenAI
import OpenAI.Data
import OpenAI.Model
import String.Case
import Task


port exit : { code : Int, msg : String } -> Cmd msg


port write : { path : String, contents : String } -> Cmd msg


unknownVariantName : String
unknownVariantName =
    "Custom"


main =
    Platform.worker
        { init = init
        , update = update
        , subscriptions = subscriptions
        }


type alias Flags =
    OpenAI.Config


type alias Model =
    { openai : OpenAI.Config
    , variants : List ( String, Elm.Variant )
    }


type Msg
    = Done (Result (Ext.Http.Error String) (List OpenAI.Model.Model))


init : Flags -> ( Model, Cmd Msg )
init config =
    ( { openai = config
      , variants = []
      }
    , OpenAI.Model.listModels
        |> OpenAI.withConfig config
        |> Http.task
        |> Task.attempt Done
    )


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        Done (Ok list) ->
            let
                variantIdNames =
                    List.map (\s -> ( s.id, variantName s )) list

                customType =
                    Elm.customType "ModelID"
                        (Elm.variantWith unknownVariantName [ Elm.Annotation.string ]
                            :: List.map (Tuple.second >> Elm.variant) variantIdNames
                        )
                        |> Elm.withDocumentation "Autogenerated custom type defining all the `model` values that can be used in the API.\n\nDO NOT edit this file by hand; execute `make cli` instead.\n\n"

                stringFromCustomType =
                    Elm.declaration "stringFromModelID"
                        (Elm.fn ( "modelId", Nothing )
                            (\modelId ->
                                Elm.Case.custom modelId
                                    (Elm.Annotation.named [] "ModelID")
                                    (Elm.Case.branch1 unknownVariantName ( "str", Elm.Annotation.string ) identity
                                        :: List.map
                                            (\( stringId, variant ) ->
                                                Elm.Case.branch0 variant (Elm.string stringId)
                                            )
                                            variantIdNames
                                    )
                            )
                        )
                        |> Elm.withDocumentation "converts to String; useful for encoding in JSON"

                customTypeFromString =
                    Elm.declaration "modelIDFromString"
                        (Elm.fn ( "str", Just Elm.Annotation.string )
                            (\str ->
                                Elm.Case.string str
                                    { cases =
                                        List.map (Tuple.mapSecond (\value -> Elm.value { importFrom = [], name = value, annotation = Nothing }))
                                            variantIdNames
                                    , otherwise =
                                        Elm.value { importFrom = [], name = unknownVariantName ++ " " ++ Elm.toString str, annotation = Just (Elm.Annotation.named [] "ModelID") }
                                    }
                            )
                        )
                        |> Elm.withDocumentation "converts from String; useful for decoding JSON"

                file =
                    Elm.file [ "OpenAI", "ModelID" ]
                        [ Elm.exposeWith { exposeConstructor = True, group = Nothing } customType
                        , Elm.expose stringFromCustomType
                        , Elm.expose customTypeFromString
                        ]
            in
            ( model
            , case file of
                { path, contents } ->
                    write { path = path, contents = contents }
            )

        Done (Err err) ->
            ( model
            , exit { code = 1, msg = Debug.toString err }
            )


subscriptions : Model -> Sub Msg
subscriptions _ =
    Sub.none



--


variantName : { a | id : String } -> String
variantName m =
    case String.split ":" m.id of
        x :: [] ->
            String.Case.toCamelCaseUpper x

        x :: xs ->
            String.Case.toCamelCaseUpper x ++ "_" ++ String.Case.toCamelCaseUpper (String.join ":" xs)

        [] ->
            m.id
